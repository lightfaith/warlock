#!/usr/bin/python3

import os
import pdb
import sys
import gnureadline
import traceback
#from datetime import datetime
#from tzlocal import get_localzone

from source import lib
from source import log
from source.parser import DB, MessageParserThread, Message
from source.commands import *

try:
    path = sys.argv[1]
except:
    log.err('Usage: %s <path>' % sys.argv[0])
    sys.exit(1)


"""
load data
"""
logs = {}

if os.path.isfile(path):
    #log.info('Dealing with file.')
    try:
        with open(path, 'r') as f:
            logs[path] = f.read().splitlines()
    except UnicodeDecodeError:
        log.err('%s is binary.' % path)

elif os.path.isdir(path):
    #log.info('Dealing with path.')
    for root, ds, fs in os.walk(path):
        for f in fs:
            filepath = os.path.join(root, f)
            try:
                with open(filepath, 'r') as f:
                    logs[filepath] = f.read().splitlines()
            except UnicodeDecodeError:
                log.err('%s is binary.' % filepath)

"""
parse events
"""

events = {}
for filename, lines in logs.items():
    file_events = {}
    log.info(filename)
    # skip /var/log/messages (non-critical stuff there)
    #      /var/log/debug.log (non-critical stuff there)
    if any([
        re.search(r'messages(\.\d)?$', filename),
        re.search(r'debug(\.log)?(\.\d)?$', filename),
    ]):
        continue
    #thread_count = 4 if len(lines) > 1000 else 1 # slower...
    thread_count = 1
    thread_line_count = len(lines) // thread_count + 1
    threads = [MessageParserThread(filename, chunk) 
               for chunk in lib.chunks(lines, thread_line_count)] 
    for t in threads:
        t.start()
    for t in threads:
        t.join()
        # add data
        lib.merge_dicts(file_events, t.results)
        #file_events += t.result

    
    # if file mtime < last event, reyear backwards
    mtime = lib.normalize_datetime(os.path.getmtime(filename))
    #log.info('  mtime:', mtime)
    try: # as timestamp might be None
        if file_events and mtime < file_events['time'][-1].timestamp:
            if Message.debug_parsing:
                log.info('  Using mtime (%s) to fix dates.' % str(mtime))
            last_event_timestamp = mtime
            
            for event in file_events['time'][::-1]:
                #print('fixing timestamp', event.timestamp)
                #print('fixing timestamp', event.message)
                event.timestamp = event.timestamp.replace(year=last_event_timestamp.year)
                if event.timestamp > last_event_timestamp:
                    #print(' decrementing year, cause actual', event.timestamp, '> last', last_event_timestamp)
                    #print('  for', event.message)
                    event.timestamp = event.timestamp.replace(year=last_event_timestamp.year - 1)
                #print(' new timestamp:', event.timestamp)
                last_event_timestamp = event.timestamp
    except:
        log.err('  Year fix failed.')
        #traceback.print_exc()
    lib.merge_dicts(events, file_events)
        
events['time'] = sorted(events['time'], key=lambda x: (x.timestamp 
                                       if x.timestamp 
                                       else lib.normalize_datetime()))
#'''
# write into DB
lib.db = DB('/tmp/warlock.db')
by_db_id = OrderedDict()
for event in events['time']:
    if event and event.timestamp:
        entry_id = lib.db.insert_message(event)
        event.db_id = entry_id
        by_db_id[entry_id] = event
lib.db.commit()
#'''

#timed_events = [e for e in events['time'] 
#                if e.category != 'UNKNOWN' and e.timestamp]
#if not timed_events:
#    log.warn('No timed events loaded.')
#    lib.exit_program(None, None)

start = events['time'][0].timestamp
end = events['time'][-1].timestamp
log.info('Found %d events from %s to %s.' % (len(events['time']), start, end))


events_limited = events['time']
"""
deal with commands
"""
while True:
    # get command
    try:
        cmd = input(log.COLOR_PURPLE + '--} ' + log.COLOR_NONE).strip()
    except EOFError: # Ctrl+D -> quit
        log.newline()
        lib.exit_program(None, None)
    if len(cmd) == 0:
        continue

    # quit?
    if lib.quit_string(cmd):
        log.warn('Do you really want to quit? ', new_line=False)
        if lib.positive(input()):
            lib.exit_program(None, None)
        continue

    # test
    if cmd.startswith('test'):
        #venn(events, 'category == auth', 'severity == critical')
        list_overview(by_db_id, 'source', 'score >= 5')
        
        pass

    # set start
    elif cmd.startswith('start '):
        value = cmd[6:]
        if value == 'reset':
            given = events['time'][0].timestamp
        else:
            given = lib.normalize_datetime(value, silent=True)
            if not given:
                display_filter = Filter.parse(value)
                filtered = [e for e in events['time']
                            if not display_filter or display_filter.test(e)]
                if filtered:
                    given = filtered[0].timestamp
        if given:
            start = given
            log.info('Working with events from %s to %s.' % (start, end))
            events_limited = [e for e in events['time'] if start <= e.timestamp <= end]
        else:
            log.err('Usage: start <datetime>|reset|<filter>')

    # set end
    elif cmd.startswith('end '):
        value = cmd[4:]
        if value == 'reset':
            given = events['time'][-1].timestamp
        else:
            given = lib.normalize_datetime(value, silent=True)
            if not given:
                display_filter = Filter.parse(value)
                filtered = [e for e in events['time']
                            if not display_filter or display_filter.test(e)]
                if filtered:
                    given = filtered[-1].timestamp
        if given:
            end = given
            log.info('Working with events from %s to %s.' % (start, end))
            events_limited = [e for e in events['time'] if start <= e.timestamp <= end]
        else:
            log.err('Usage: end <datetime>|reset|<filter>')

    # list events
    elif cmd.startswith('list events'):
        """
        list detailed events based on optional display filter
        """
        log.info('Showing events from %s to %s.' % (start, end))
        list_events(by_db_id, cmd[12:])

    # list suspicious
    elif cmd.startswith('suspicious'):
        try:
            log.info('Showing suspicious for events from %s to %s.' % (start, end))

            list_suspicious(events_limited, cmd.split()[1], ' '.join(cmd.split()[2:]))
        except:
            traceback.print_exc()
            log.err('Usage: suspicious ip|user [<filter>]')
    
    # list X
    elif cmd.startswith('list'):
        try:
            log.info('Showing counts for events from %s to %s.' % (start, end))

            list_overview(by_db_id, cmd.split()[1], ' '.join(cmd.split()[2:]))

        except:
            traceback.print_exc()
            log.err('Usage: list events|source|category|<attribute> [<filter>]')
   
    # plot
    elif cmd.startswith('plot'):
        plot(events_limited, cmd[4:])

    else:
        log.warn('Unknown command.')

